# 位运算及其应用
## 三种常见的运算
### 按位与(&)
-   定义: 两个二进制数进行与运算,如果两个数都为1,则结果为1,否则为0
-   常见应用: 判断数字的奇偶性;n & (n-1)能够消灭最后一个1
>   100101001101101 & 0000000000001                                      
>   让被判断的数字和 1 进行按位与运算，结果如果是0说明是偶数否则是奇数

>   00000101 & 00000100 = 00000100                                                                                  
>   n=5时,4的十进制00000101,4的十进制为00000100,与之后的数为00000100,消除了最后一个1


### 按位或(|)
-   定义: 两个二进制数进行或运算,如果对应位有一个为1,结果就为1。只有在两个数的对应位置都是0的时候,结果才为0。
-   常见应用: 用于二进制特定位的赋值,使用a|1把a的最后一位强行变成1，其实质意义是把原数加一
>   00000000 | 00000001 
>   让特定位置和1进行按位或运算,结果说明为0+1


### 按位异或(^)
-   定义: 两个二进制数进行异或运算, 如果对应位相同, 则为0, 反之为1。交换律:0^a=a,a^a=0
-   常见应用: 解决两个数之间有关不同位的数量等各种问题


### 例题分析(利用技巧n & (n-1)消除最后一个1)
#### 汉明重量(返回二进制表达式中数字位数为 ‘1’ 的个数)
-   技巧:利用技巧n & (n-1)依次消除最后一位数,直至全部不为1 
-   定义一个新的变量存放为1的个数
>   class Solution:                                                
>    def hammingWeight(self, n: int) -> int:                            
>        count=0                              
>        while n!=0:                              
>            n=n&(n-1)                                                        
>            count+=1
>        return count                                             

#### 汉明距离(两个数字对应二进制位不同的位置的数目)
-   利用异或得出一个新的数字,1即代表了原两个数的不同位,定义一个新的变量存放为1的个数
-   利用技巧n & (n-1)依次消除最后一位数,直至全部不为1 
>   def hammingDistance(self, x: int, y: int) -> int:                               
>      a=x^y                                     
>       count=0                                           
>       while a!=0:                                                 
>          a=a & (a-1)                                                     
>          count+=1                                            
>       return count                                                      

#### 汉明距离总和(任意两个数之间汉明距离的总和)
-   技巧:需要两次遍历
-   弊端:运行超时
>   def totalHammingDistance(nums: List[int]) -> int:
>    count = 0
>    for i in range(len(nums) - 1):
>        for j in range(i + 1, len(nums)):
>            a = nums[i] ^ nums[j]
>            while a != 0:
>                a = a & (a - 1)
>                count += 1
>    return count 

-   技巧:一个数占4个字节,一个字节8个位,因此外侧for循环可简化为32,即取0-31   
-   第j个数右移i位,和1做与运算,只关注最后一位是0还是1
>   def totalHammingDistance(self, nums: List[int]) -> int:
>      count = 0                                            
>      for i in range(32):                                                          
>          count_0=0                                                        
>          count_1=0                                                                    
>          for j in range(len(nums)):                                                       
>              if(nums[j] >> i) & 1:                                                                    
>                  count_1+=1                                                           
>              else:                                                                    
>                  count_0+=1                                                                         
>          count=count + count_0 * count_1                                                                          
>      return count                                                                       
